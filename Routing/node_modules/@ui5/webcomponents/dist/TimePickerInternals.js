var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TimePickerInternals_1;
import UI5Element from "@ui5/webcomponents-base/dist/UI5Element.js";
import customElement from "@ui5/webcomponents-base/dist/decorators/customElement.js";
import property from "@ui5/webcomponents-base/dist/decorators/property.js";
import event from "@ui5/webcomponents-base/dist/decorators/event.js";
import { getI18nBundle } from "@ui5/webcomponents-base/dist/i18nBundle.js";
import getLocale from "@ui5/webcomponents-base/dist/locale/getLocale.js";
import DateFormat from "@ui5/webcomponents-localization/dist/DateFormat.js";
import getCachedLocaleDataInstance from "@ui5/webcomponents-localization/dist/getCachedLocaleDataInstance.js";
import "@ui5/webcomponents-localization/dist/features/calendar/Gregorian.js"; // default calendar for bundling
import CalendarType from "@ui5/webcomponents-base/dist/types/CalendarType.js";
import { fetchCldr } from "@ui5/webcomponents-base/dist/asset-registries/LocaleData.js";
import Integer from "@ui5/webcomponents-base/dist/types/Integer.js";
import { getHoursConfigByFormat, getTimeControlsByFormat, } from "./timepicker-utils/TimeSlider.js";
import { TIMEPICKER_HOURS_LABEL, TIMEPICKER_MINUTES_LABEL, TIMEPICKER_SECONDS_LABEL, TIMEPICKER_CLOCK_DIAL_LABEL, } from "./generated/i18n/i18n-defaults.js";
/**
 * @class
 *
 * <h3 class="comment-api-title">Overview</h3>
 *
 * <code>ui5-time-picker-internals</code> is helper component that contains shared methods used in <code>ui5-time-selection-clocks</code>
 * and <ui5-time-selection-inputs> components and should not be used separately.
 *
 * @constructor
 * @author SAP SE
 * @alias sap.ui.webc.main.TimePickerInternals
 * @extends sap.ui.webc.base.UI5Element
 * @abstract
 * @tagname ui5-time-picker-internals
 * @since 1.15.0
 * @private
 */
let TimePickerInternals = TimePickerInternals_1 = class TimePickerInternals extends UI5Element {
    static async onDefine() {
        [TimePickerInternals_1.i18nBundle] = await Promise.all([
            getI18nBundle("@ui5/webcomponents"),
            fetchCldr(getLocale().getLanguage(), getLocale().getRegion(), getLocale().getScript()),
        ]);
    }
    get _hoursConfiguration() {
        // @ts-ignore aFormatArray is a private API of DateFormat
        const formatArray = this.getFormat().aFormatArray;
        const hourFormat = formatArray.find(item => item.type.startsWith("hour")); // try to find an entry for the hours
        return getHoursConfigByFormat(hourFormat ? hourFormat.type : "hour0_23");
    }
    get _zeroPaddedHours() {
        // @ts-ignore aFormatArray is a private API of DateFormat
        const formatArray = this.getFormat().aFormatArray;
        const hourFormat = formatArray.find(item => item.type.startsWith("hour")); // try to find an entry for the hours
        // @ts-ignore digits is a private API of aFormatArray
        return !(hourFormat.digits && hourFormat.digits === 1);
    }
    get _neededComponents() {
        // @ts-ignore aFormatArray is a private API of DateFormat
        const formatArray = this.getFormat().aFormatArray;
        return getTimeControlsByFormat(formatArray, this._hoursConfiguration);
    }
    get _hasHoursComponent() {
        return this._neededComponents[0];
    }
    get _hasMinutesComponent() {
        return this._neededComponents[1];
    }
    get _hasSecondsComponent() {
        return this._neededComponents[2];
    }
    get _hasPeriodsComponent() {
        return this._neededComponents[3];
    }
    get dateValue() {
        return this.value ? this.getFormat().parse(this.value, undefined, undefined) : new Date();
    }
    get validDateValue() {
        return this.value !== undefined && this.isValid(this.value) ? this.dateValue : new Date();
    }
    get periodsArray() {
        // @ts-ignore aDayPeriodsAbbrev is a private API of DateFormat
        const dayPeriodsAbbrev = this.getFormat().aDayPeriodsAbbrev;
        return dayPeriodsAbbrev.map((x) => x.toUpperCase());
    }
    get _showAmPmButton() {
        return true;
    }
    get _pmPressed() {
        return false;
    }
    get _hours() {
        let hours;
        const dateValue = this.validDateValue;
        if (this._hoursConfiguration.isTwelveHoursFormat && dateValue.getHours() > this._hoursConfiguration.maxHour) {
            hours = dateValue.getHours() - 12;
        }
        else if (this._hoursConfiguration.isTwelveHoursFormat && dateValue.getHours() < this._hoursConfiguration.minHour) {
            hours = dateValue.getHours() + 12;
        }
        else {
            hours = dateValue.getHours();
        }
        if (hours.toString().length === 1 && this._zeroPaddedHours) {
            hours = `0${hours}`;
        }
        return hours.toString();
    }
    get _minutes() {
        const minutes = this.validDateValue.getMinutes().toString();
        return minutes.length === 1 ? `0${minutes}` : minutes;
    }
    get _seconds() {
        const seconds = this.validDateValue.getSeconds().toString();
        return seconds.length === 1 ? `0${seconds}` : seconds;
    }
    get _period() {
        if (!this._hoursConfiguration.isTwelveHoursFormat) {
            return undefined;
        }
        let period;
        const dateValue = this.validDateValue;
        if (this._hoursConfiguration.minHour === 1) {
            period = dateValue.getHours() >= this._hoursConfiguration.maxHour ? this.periodsArray[1] : this.periodsArray[0];
        }
        else {
            period = (dateValue.getHours() > this._hoursConfiguration.maxHour || dateValue.getHours() === this._hoursConfiguration.minHour) ? this.periodsArray[1] : this.periodsArray[0];
        }
        return period;
    }
    get _formatPattern() {
        const pattern = this.formatPattern;
        const hasHours = !!pattern.match(/H/i);
        const fallback = !pattern || !hasHours;
        const localeData = getCachedLocaleDataInstance(getLocale());
        return fallback ? localeData.getCombinedDateTimePattern("medium", "medium", undefined) : pattern;
    }
    get _isPattern() {
        return this._formatPattern !== "medium" && this._formatPattern !== "short" && this._formatPattern !== "long";
    }
    get hoursLabel() {
        return TimePickerInternals_1.i18nBundle.getText(TIMEPICKER_HOURS_LABEL);
    }
    get minutesLabel() {
        return TimePickerInternals_1.i18nBundle.getText(TIMEPICKER_MINUTES_LABEL);
    }
    get secondsLabel() {
        return TimePickerInternals_1.i18nBundle.getText(TIMEPICKER_SECONDS_LABEL);
    }
    get clockDialAriaLabel() {
        return TimePickerInternals_1.i18nBundle.getText(TIMEPICKER_CLOCK_DIAL_LABEL);
    }
    get _nextSeparator() {
        const sep = this._separators.shift() || "";
        return sep;
    }
    setValue(date) {
        const value = this.formatValue(date);
        if (this.isValid(value)) {
            this.value = this.normalizeValue(value);
            this.fireEvent("change", { value: this.value, valid: true });
        }
    }
    isValid(value) {
        return value === "" || this.getFormat().parse(value, undefined, undefined);
    }
    normalizeValue(value) {
        if (value === "") {
            return value;
        }
        return this.getFormat().format(this.getFormat().parse(value, undefined, undefined));
    }
    getFormat() {
        let dateFormat;
        if (this._isPattern) {
            dateFormat = DateFormat.getDateInstance({
                calendarType: this._calendarType,
                pattern: this._formatPattern,
            });
        }
        else {
            dateFormat = DateFormat.getDateInstance({
                calendarType: this._calendarType,
                style: this._formatPattern,
            });
        }
        return dateFormat;
    }
    formatValue(date) {
        return this.getFormat().format(date);
    }
    _componentKey(name) {
        const key = name;
        return key;
    }
    _getSeparators() {
        // @ts-ignore aFormatArray is a private API of DateFormat
        const formatArray = this.getFormat().aFormatArray;
        let previousWasEntity = false;
        let index;
        this._separators = [];
        if (!formatArray.length) {
            return;
        }
        if (formatArray[0].type !== "text") {
            this._separators.push("");
        }
        for (index = 0; index < formatArray.length; index++) {
            if (formatArray[index].type !== "text") {
                if (previousWasEntity) {
                    // there was previous non-separator entity, and this one is the same too, so add empty separator
                    this._separators.push("");
                }
                else {
                    // this is non-separator entity, set the entity flag
                    previousWasEntity = true;
                }
            }
            else {
                // add separator and clear non-separator entity flag
                this._separators.push(formatArray[index].value);
                previousWasEntity = false;
            }
        }
        // push one more empty separator for the last entity
        if (formatArray[index - 1].type !== "text") {
            this._separators.push("");
        }
    }
    _buttonAmPm() {
        return this._hasPeriodsComponent ? this.shadowRoot?.querySelector(`#${this._id}_AmPm`) : undefined;
    }
    _periodChange(evt) {
        const periodItem = evt.target;
        if (periodItem) {
            const period = periodItem.textContent;
            this._calculatePeriodChange(period);
        }
    }
    _calculatePeriodChange(period) {
        const date = this.validDateValue;
        if (period === this._periods[0].label && date.getHours() >= 12) {
            date.setHours(date.getHours() - 12);
        }
        if (period === this._periods[1].label && date.getHours() < 12) {
            date.setHours(date.getHours() + 12);
        }
        this.setValue(date);
    }
};
__decorate([
    property({ defaultValue: undefined })
], TimePickerInternals.prototype, "value", void 0);
__decorate([
    property()
], TimePickerInternals.prototype, "formatPattern", void 0);
__decorate([
    property({ validator: Integer, defaultValue: 1 })
], TimePickerInternals.prototype, "minutesStep", void 0);
__decorate([
    property({ validator: Integer, defaultValue: 1 })
], TimePickerInternals.prototype, "secondsStep", void 0);
__decorate([
    property({ validator: Integer, defaultValue: 0, noAttribute: true })
], TimePickerInternals.prototype, "_activeIndex", void 0);
__decorate([
    property({ type: CalendarType })
], TimePickerInternals.prototype, "_calendarType", void 0);
__decorate([
    property({ type: Object })
], TimePickerInternals.prototype, "_componentMap", void 0);
__decorate([
    property({ type: Object, multiple: true })
], TimePickerInternals.prototype, "_periods", void 0);
__decorate([
    property({ multiple: true })
], TimePickerInternals.prototype, "_separators", void 0);
__decorate([
    property({ defaultValue: "", noAttribute: true })
], TimePickerInternals.prototype, "_amPmSeparator", void 0);
__decorate([
    property({ defaultValue: "", noAttribute: true })
], TimePickerInternals.prototype, "_lastSeparator", void 0);
TimePickerInternals = TimePickerInternals_1 = __decorate([
    customElement({
        tag: "ui5-time-picker-internals",
    })
    /**
     * Fired when the value changes due to user interaction with the sliders.
     */
    ,
    event("change", {
        detail: {
            value: { type: String },
            valid: { type: Boolean },
        },
    })
], TimePickerInternals);
TimePickerInternals.define();
export default TimePickerInternals;
//# sourceMappingURL=TimePickerInternals.js.map