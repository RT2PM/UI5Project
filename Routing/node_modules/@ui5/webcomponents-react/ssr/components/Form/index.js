'use client';

import { Device, useSyncRef } from '@ui5/webcomponents-react-base';
import { clsx } from 'clsx';
import React, { forwardRef, useCallback, useEffect, useMemo, useReducer, useRef, useState } from 'react';
import { createUseStyles } from 'react-jss';
import { FormBackgroundDesign, TitleLevel } from '../../enums/index.js';
import { Title } from '../../webComponents/index.js';
import { styles } from './Form.jss.js';
import { FormContext } from './FormContext.js';
const recalcReducerFn = prev => {
  return prev + 1;
};
const useStyles = createUseStyles(styles, {
  name: 'Form'
});
/**
 * The `Form` component arranges labels and fields into groups and rows. There are different ways to visualize forms for different screen sizes.
 * It is possible to change the alignment of all labels by setting the CSS `align-items` property, per default all labels are centered.
 *
 * __Note:__ The `Form` calculates its width based on the available space of its container. If the container also dynamically adjusts its width to its contents, you must ensure that you specify a fixed width, either for the container or for the `Form` itself. (e.g. when used inside a 'popover').
 */
const Form = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    as = 'form',
    backgroundDesign = FormBackgroundDesign.Transparent,
    children,
    columnsS = 1,
    columnsM = 1,
    columnsL = 1,
    columnsXL = 2,
    className,
    labelSpanS = 12,
    labelSpanM = 2,
    labelSpanL = 4,
    labelSpanXL = 4,
    titleText,
    style,
    ...rest
  } = props;
  const [items, setItems] = useState(() => new Map());
  const classes = useStyles();
  const columnsMap = new Map();
  columnsMap.set('Phone', columnsS);
  columnsMap.set('Tablet', columnsM);
  columnsMap.set('Desktop', columnsL);
  columnsMap.set('LargeDesktop', columnsXL);
  const labelSpanMap = new Map();
  labelSpanMap.set('Phone', labelSpanS);
  labelSpanMap.set('Tablet', labelSpanM);
  labelSpanMap.set('Desktop', labelSpanL);
  labelSpanMap.set('LargeDesktop', labelSpanXL);
  const [componentRef, formRef] = useSyncRef(ref);
  // use the window range set as first best guess, if not available use Desktop
  const [currentRange, setCurrentRange] = useState(Device.getCurrentRange()?.name ?? 'Desktop');
  const lastRange = useRef(currentRange);
  useEffect(() => {
    const observer = new ResizeObserver(([form]) => {
      const rangeInfo = Device.getCurrentRange(form.contentRect.width);
      if (rangeInfo && lastRange.current !== rangeInfo.name) {
        lastRange.current = rangeInfo.name;
        setCurrentRange(rangeInfo.name);
      }
    });
    if (formRef.current) {
      observer.observe(formRef.current);
    }
    return () => {
      observer.disconnect();
    };
  }, [formRef]);
  const currentLabelSpan = labelSpanMap.get(currentRange);
  const currentNumberOfColumns = columnsMap.get(currentRange);
  const registerItem = useCallback((id, type, groupId) => {
    setItems(prev => {
      const clonedMap = new Map(prev);
      if (groupId) {
        const groupItem = clonedMap.get(groupId);
        if (groupItem) {
          groupItem.formItemIds = new Set(groupItem.formItemIds).add(id);
        } else {
          clonedMap.set(groupId, {
            type: 'formGroup',
            formItemIds: new Set([id])
          });
        }
      } else {
        if (!clonedMap.has(id)) {
          clonedMap.set(id, {
            type,
            formItemIds: new Set()
          });
        }
      }
      return clonedMap;
    });
  }, []);
  const unregisterItem = useCallback((id, groupId) => {
    setItems(state => {
      const clonedMap = new Map(state);
      if (groupId) {
        const groupItem = clonedMap.get(groupId);
        if (groupItem) {
          groupItem.formItemIds.delete(id);
        }
      } else {
        clonedMap.delete(id);
      }
      return clonedMap;
    });
  }, []);
  const formLayoutContextValue = useMemo(() => {
    const formItems = [];
    const formGroups = [];
    let index = -1;
    let localColumnIndex = 0;
    // depending on the labelSpan, each form item takes up either 1 (labelSpan < 12) or 2 (labelSpan == 12) rows
    const rowsPerFormItem = currentLabelSpan === 12 ? 2 : 1;
    let rowIndex = (titleText ? 2 : 1) + rowsPerFormItem - 1;
    // no. of rows in a "line" - e.g. when a group has 5 items, the next line needs to start below that group
    let nextRowIndex = rowIndex;
    const rowsWithGroup = {};
    items.forEach(({
      type,
      formItemIds
    }, id) => {
      const columnIndex = localColumnIndex % currentNumberOfColumns;
      index++;
      if (type === 'formGroup') {
        rowsWithGroup[rowIndex] = true;
        formGroups.push({
          id,
          index,
          columnIndex,
          rowIndex
        });
        let localRowIndex = 1;
        let localIndex = 1;
        if (!formItemIds.size) {
          nextRowIndex++;
        }
        formItemIds.forEach((itemId, _, set) => {
          formItems.push({
            id: itemId,
            index,
            groupId: id,
            columnIndex,
            rowIndex: rowIndex + localRowIndex,
            lastGroupItem: set.size === localIndex
          });
          if (set.size === localIndex) {
            if (nextRowIndex < rowIndex + localRowIndex + rowsPerFormItem) {
              nextRowIndex = rowIndex + localRowIndex + rowsPerFormItem;
            }
          }
          localRowIndex += rowsPerFormItem;
          localIndex++;
        });
      } else {
        if (nextRowIndex < rowIndex + 1) {
          nextRowIndex += rowsPerFormItem;
        }
        formItems.push({
          id,
          index,
          columnIndex,
          rowIndex
        });
      }
      if ((localColumnIndex + 1) % currentNumberOfColumns === 0) {
        rowIndex = nextRowIndex;
      }
      localColumnIndex++;
    });
    return {
      formItems,
      formGroups,
      registerItem,
      unregisterItem,
      rowsWithGroup
    };
  }, [items, registerItem, unregisterItem, currentNumberOfColumns, titleText, currentLabelSpan]);
  const formClassNames = clsx(classes.form, classes[backgroundDesign.toLowerCase()]);
  const CustomTag = as;
  const prevFormItems = useRef(undefined);
  const prevFormGroups = useRef(undefined);
  const [recalcTrigger, fireRecalc] = useReducer(recalcReducerFn, 0, undefined);
  useEffect(() => {
    if (prevFormItems.current || prevFormGroups.current) {
      let hasChanged = formLayoutContextValue.formItems.length !== prevFormItems.current.length || formLayoutContextValue.formGroups.length !== prevFormGroups.current.length;
      if (!hasChanged) {
        hasChanged = !formLayoutContextValue.formGroups.every((item, index) => prevFormGroups.current.findIndex(element => element.id === item.id) === index);
      }
      if (!hasChanged) {
        hasChanged = !formLayoutContextValue.formItems.every((item, index) => prevFormItems.current.findIndex(element => element.id === item.id) === index);
      }
      if (hasChanged) {
        fireRecalc();
      }
    }
    prevFormItems.current = formLayoutContextValue.formItems;
    prevFormGroups.current = formLayoutContextValue.formGroups;
  }, [formLayoutContextValue.formItems, formLayoutContextValue.formGroups]);
  return /*#__PURE__*/React.createElement(FormContext.Provider, {
    value: {
      ...formLayoutContextValue,
      labelSpan: currentLabelSpan,
      recalcTrigger
    }
  }, /*#__PURE__*/React.createElement(CustomTag, {
    className: clsx(classes.formContainer, className),
    suppressHydrationWarning: true,
    ref: componentRef,
    style: {
      ...style,
      '--_ui5wcr_form_label_span_s': labelSpanS,
      '--_ui5wcr_form_label_span_m': labelSpanM,
      '--_ui5wcr_form_label_span_l': labelSpanL,
      '--_ui5wcr_form_label_span_xl': labelSpanXL,
      '--_ui5wcr_form_columns_s': columnsS,
      '--_ui5wcr_form_columns_m': columnsM,
      '--_ui5wcr_form_columns_l': columnsL,
      '--_ui5wcr_form_columns_xl': columnsXL
    },
    ...rest
  }, /*#__PURE__*/React.createElement("div", {
    className: formClassNames
  }, titleText && /*#__PURE__*/React.createElement(Title, {
    level: TitleLevel.H3,
    className: classes.formTitle,
    style: {
      gridColumn: '1 / -1'
    }
  }, titleText), children)));
});
Form.displayName = 'Form';
export { Form };